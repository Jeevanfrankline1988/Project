<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Snake Game — Flask</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
  <div class="container">
    <h1>Snake — Play in your browser</h1>

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>
      <span class="score">Score: <span id="score">0</span></span>
      <span class="speed">Speed: <span id="speed">8</span></span>
    </div>

    <canvas id="gameCanvas" width="480" height="480"></canvas>

    <p class="instructions">
      Controls: arrow keys or WASD to move. Press <strong>Space</strong> to restart after Game Over.
    </p>
  </div>

<script>
/* --- Simple Snake game (vanilla JS) --- */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const scoreEl = document.getElementById('score');
const speedEl = document.getElementById('speed');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

const gridSize = 20;                // size of one square
const tileCount = canvas.width / gridSize; // number of tiles per row/col

let snake = [{x: 10, y: 10}];      // starting snake body (array of segments)
let dir = {x: 0, y: 0};            // direction vector
let food = {x: 5, y: 5};
let score = 0;
let speed = 8;                     // updates per second
let gameLoopId = null;
let paused = true;
let gameOver = false;

function randTile() {
  return Math.floor(Math.random() * tileCount);
}

function placeFood() {
  let valid = false;
  while (!valid) {
    food.x = randTile();
    food.y = randTile();
    valid = !snake.some(s => s.x === food.x && s.y === food.y);
  }
}

function resetGame() {
  snake = [{x: 10, y: 10}];
  dir = {x: 0, y: 0};
  score = 0;
  speed = 8;
  scoreEl.textContent = score;
  speedEl.textContent = speed;
  paused = true;
  gameOver = false;
  placeFood();
  draw();
}

function drawCell(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
}

function drawGrid() {
  ctx.fillStyle = "#111";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function draw() {
  drawGrid();
  // food
  drawCell(food.x, food.y, "#e74c3c");

  // snake
  for (let i = 0; i < snake.length; i++) {
    const s = snake[i];
    drawCell(s.x, s.y, i === 0 ? "#2ecc71" : "#27ae60");
  }

  if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0, canvas.height/2 - 40, canvas.width, 80);
    ctx.fillStyle = "#fff";
    ctx.font = "24px monospace";
    ctx.textAlign = "center";
    ctx.fillText("Game Over — Press Space to Restart", canvas.width/2, canvas.height/2 + 8);
  }
}

function update() {
  if (paused || gameOver) return;

  // move snake head
  const head = {x: (snake[0].x + dir.x + tileCount) % tileCount,
                y: (snake[0].y + dir.y + tileCount) % tileCount};

  // check self collision
  if (snake.some((s, idx) => idx > 0 && s.x === head.x && s.y === head.y)) {
    gameOver = true;
    paused = true;
    draw();
    return;
  }

  // add head
  snake.unshift(head);

  // eat food?
  if (head.x === food.x && head.y === food.y) {
    score += 1;
    scoreEl.textContent = score;
    // increase speed gradually
    if (score % 3 === 0) {
      speed = Math.min(20, speed + 1);
      speedEl.textContent = speed;
      restartLoop(); // apply new speed
    }
    placeFood();
  } else {
    // remove tail
    snake.pop();
  }

  draw();
}

/* Game loop controlled with setInterval so speed changes are simple */
function startLoop() {
  if (gameLoopId) clearInterval(gameLoopId);
  gameLoopId = setInterval(update, 1000 / speed);
  paused = false;
}

function restartLoop() {
  if (gameLoopId) clearInterval(gameLoopId);
  gameLoopId = setInterval(update, 1000 / speed);
}

function stopLoop() {
  if (gameLoopId) clearInterval(gameLoopId);
  gameLoopId = null;
  paused = true;
}

document.addEventListener('keydown', (e) => {
  if (gameOver && e.code === "Space") {
    resetGame();
    startLoop();
    return;
  }

  switch (e.key) {
    case 'ArrowUp':
    case 'w':
    case 'W':
      if (dir.y === 1) break;
      dir = {x: 0, y: -1};
      break;
    case 'ArrowDown':
    case 's':
    case 'S':
      if (dir.y === -1) break;
      dir = {x: 0, y: 1};
      break;
    case 'ArrowLeft':
    case 'a':
    case 'A':
      if (dir.x === 1) break;
      dir = {x: -1, y: 0};
      break;
    case 'ArrowRight':
    case 'd':
    case 'D':
      if (dir.x === -1) break;
      dir = {x: 1, y: 0};
      break;
    case ' ':
      if (paused && !gameOver) {
        startLoop();
      } else if (!paused && !gameOver) {
        stopLoop();
      }
      break;
  }
});

startBtn.addEventListener('click', () => {
  if (!gameOver) startLoop();
});
pauseBtn.addEventListener('click', () => {
  stopLoop();
});
resetBtn.addEventListener('click', () => {
  resetGame();
});

window.addEventListener('blur', () => {
  // pause when user switches tabs
  stopLoop();
});

resetGame();
draw();

</script>
</body>
</html>
